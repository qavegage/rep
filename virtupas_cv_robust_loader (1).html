<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>VirtuPas — CV demo (robust loaders)</title>
<style>
  :root{--bg:#0f1115;--fg:#e8eaed;--muted:#9aa0a6;--card:#131a24;--b:#263141}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  main{max-width:980px;margin:18px auto;padding:0 12px}
  h1{font-size:18px;margin:12px 0}
  .bar{display:flex;justify-content:flex-end;margin:10px 0}
  .toggle{display:inline-flex;gap:8px;align-items:center;font-size:12px;color:#bcd2f5}
  .card{background:var(--card);border:1px solid var(--b);border-radius:12px;padding:12px}
  .samples{display:flex;gap:12px;flex-wrap:wrap}
  .samples img{height:140px;width:auto;border:1px solid var(--b);border-radius:10px;cursor:pointer;background:#0b1118}
  .actions{display:flex;gap:8px;margin-top:10px}
  .btn{background:#152235;color:#cfe8ff;border:1px solid #31527c;border-radius:10px;padding:8px 12px;cursor:pointer}
  .status{font-size:12px;color:#9aa0a6;margin:8px 0}
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(3px);z-index:10001}
  .panel{background:#0f1420;border:1px solid #22324a;border-radius:12px;width:min(980px,96vw);max-height:92vh;display:grid;grid-template-columns:1.2fr .8fr;gap:12px;padding:12px;position:relative;}
  .close{position:absolute;top:8px;right:8px;background:#1a2233;border:1px solid #2b334a;color:#cfe0ff;border-radius:8px;padding:4px 8px;cursor:pointer}
  .canvasbox{background:#0b1118;border:1px solid #283247;border-radius:10px;padding:8px;overflow:auto}
  .logbox{background:#0b1118;border:1px solid #283247;border-radius:10px;padding:10px;display:flex;flex-direction:column;overflow:auto}
  .log{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
  .badge{background:#12233a;border:1px solid #2b3c5a;border-radius:8px;padding:2px 6px;font-size:12px;margin-right:6px}
  input[type="file"]{color:#e8eaed}
</style>
</head>
<body>
<main>
  <h1>VirtuPas — Computer Vision demo</h1>
  <div class="bar">
    <label class="toggle"><input id="cv-toggle" type="checkbox"/> <span id="cv-label">computer vision proberen</span></label>
  </div>
  <div class="card">
    <div class="status" id="status">Klaar</div>
    <div class="actions">
      <input type="file" id="file" accept="image/*"/>
      <button class="btn" id="test1">Laad demo 1 (lichaam)</button>
      <button class="btn" id="test2">Laad demo 2 (yoga)</button>
      <button class="btn" id="test3">Laad demo 3 (hardlopen)</button>
    </div>
    <div class="samples" id="samples"></div>
  </div>
</main>

<div class="overlay" id="ovl">
  <div class="panel">
    <button class="close" id="close">×</button>
    <div class="canvasbox"><canvas id="cv" style="max-width:100%;height:auto;border-radius:8px;background:#0b1118"></canvas></div>
    <div class="logbox">
      <div><span class="badge">Analyse</span><span id="phase" class="status">Gereed</span></div>
      <div id="log" class="log"></div>
      <div id="out" class="log" style="margin-top:8px"></div>
    </div>
  </div>
</div>

<script>
// ---------- robust script loader with mirrors ----------
async function loadScript(urls){
  for(const u of urls){
    try{
      await new Promise((res, rej)=>{
        const s = document.createElement('script');
        s.src = u; s.async = true; s.onload = res; s.onerror = ()=>rej(new Error('load failed '+u));
        document.head.appendChild(s);
      });
      return true;
    }catch(e){ /* try next */ }
  }
  return false;
}
function log(t){ const el=document.getElementById('log'); el.textContent += (el.textContent?'\n':'') + t; }
function setPhase(t){ document.getElementById('phase').textContent = t; }
function setStatus(t){ document.getElementById('status').textContent = t; }
function showO(){ document.getElementById('ovl').style.display='flex'; }
function hideO(){ document.getElementById('ovl').style.display='none'; }

// ---------- backends ----------
let backend = null, landmarker = null, detector = null;

async function ensureBackend(){
  if(backend) return backend;
  setPhase('Laden van libraries…');

  // Try MediaPipe Tasks Vision
  const ok1 = await loadScript([
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.js",
    "https://unpkg.com/@mediapipe/tasks-vision@0.10.14/vision_bundle.js"
  ]);
  if(ok1 && window.FilesetResolver && window.PoseLandmarker){
    try{
      setPhase('Init MediaPipe Tasks…');
      const vision = await window.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
      landmarker = await window.PoseLandmarker.createFromOptions(vision, {
        baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task" },
        runningMode:"IMAGE", numPoses:1,
        minPoseDetectionConfidence:0.35, minPosePresenceConfidence:0.35, minTrackingConfidence:0.35
      });
      backend = 'tasks';
      log('Backend: MediaPipe Tasks Vision');
      return backend;
    }catch(e){ log('Tasks init fail: '+e); }
  }

  // Fallback to TFJS + pose-detection
  const ok2 = await loadScript([
    "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.21.0/dist/tf-core.min.js",
    "https://unpkg.com/@tensorflow/tfjs-core@4.21.0/dist/tf-core.min.js"
  ]);
  const ok3 = await loadScript([
    "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.21.0/dist/tf-backend-webgl.min.js",
    "https://unpkg.com/@tensorflow/tfjs-backend-webgl@4.21.0/dist/tf-backend-webgl.min.js"
  ]);
  const ok4 = await loadScript([
    "https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.4.0/dist/pose-detection.min.js",
    "https://unpkg.com/@tensorflow-models/pose-detection@3.4.0/dist/pose-detection.min.js"
  ]);
  const ok5 = await loadScript([
    "https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5",
    "https://unpkg.com/@mediapipe/pose@0.5"
  ]);

  if(ok2 && ok3 && ok4 && ok5 && window.poseDetection){
    try{
      setPhase('Init TFJS backend…');
      if(window.tf && tf.setBackend){ try{ await tf.setBackend('webgl'); await tf.ready(); }catch(_){ } }
      // Try BlazePose
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.BlazePose, {
        runtime:'mediapipe', modelType:'full', solutionPath:'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5'
      });
      backend = 'tfjs';
      log('Backend: TFJS BlazePose');
      return backend;
    }catch(e1){
      log('BlazePose init fail: '+e1);
      try{
        // Try MoveNet Lightning
        detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
        });
        backend = 'tfjs';
        log('Backend: TFJS MoveNet');
        return backend;
      }catch(e2){ log('MoveNet init fail: '+e2); }
    }
  }

  throw new Error('Geen pose backend beschikbaar.');
}

// ---------- drawing and estimates ----------
function drawPose(img, points, normalized){
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  canvas.width = img.naturalWidth || img.width;
  canvas.height = img.naturalHeight || img.height;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#4cc9f0'; ctx.strokeStyle='#b5179e'; ctx.lineWidth=2;
  function toPx(p){ return normalized? {x:p.x*canvas.width, y:p.y*canvas.height} : p; }
  points.forEach(p=>{ const q=toPx(p); if(isNaN(q.x)||isNaN(q.y)) return; ctx.beginPath(); ctx.arc(q.x,q.y,3,0,Math.PI*2); ctx.fill(); });
  const N = mapByName(points, normalized);
  const bones = [['left_shoulder','right_shoulder'],['left_hip','right_hip'],['left_shoulder','left_elbow'],['left_elbow','left_wrist'],['right_shoulder','right_elbow'],['right_elbow','right_wrist'],['left_hip','left_knee'],['left_knee','left_ankle'],['right_hip','right_knee'],['right_knee','right_ankle']];
  bones.forEach(([a,b])=>{ if(N[a]&&N[b]){ const A=toPx(N[a]), B=toPx(N[b]); ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); }});
}
const MP_NAMES=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];
function mapByName(points, normalized){
  const named={};
  if(normalized){ points.forEach((p,i)=>{ const nm=MP_NAMES[i]||('p'+i); named[nm]={x:p.x,y:p.y}; }); }
  else{ points.forEach(p=>{ const nm=p.name||p.part||''; if(nm) named[nm]={x:p.x,y:p.y}; }); }
  return named;
}
function hypot(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function estimate(points, normalized, priorCm){
  const N=mapByName(points, normalized);
  const required=['left_shoulder','right_shoulder','left_hip','right_hip','left_ankle','right_ankle','nose'];
  const missing=required.filter(k=>!N[k]);
  const res={detected:[], missing:missing.slice(), chest:null,waist:null,hip:null,shoulder:null,scale:null,height:priorCm||null};
  if(missing.length) return res;
  const topY=Math.min(N.nose.y,N.left_shoulder.y,N.right_shoulder.y);
  const bottomY=Math.max(N.left_ankle.y,N.right_ankle.y);
  const h=bottomY-topY;
  let cmPerUnit=null; if(priorCm && h>0) cmPerUnit=priorCm/h;
  const sh=hypot(N.left_shoulder,N.right_shoulder);
  const hip=hypot(N.left_hip,N.right_hip);
  const chest = cmPerUnit? Math.round(sh*cmPerUnit*1.5):null;
  const waist = cmPerUnit? Math.round(hip*cmPerUnit*0.95):null;
  const hipcm = cmPerUnit? Math.round(hip*cmPerUnit*1.05):null;
  const shoulder = cmPerUnit? Math.round(sh*cmPerUnit):null;
  res.scale=cmPerUnit; res.chest=chest; res.waist=waist; res.hip=hipcm; res.shoulder=shoulder; res.detected=['nose','shoulders','hips','ankles'];
  return res;
}

// ---------- analyze ----------
async function analyze(src){
  showO(); document.getElementById('log').textContent=''; setPhase('Afbeelding laden…');
  const img=new Image(); img.crossOrigin='anonymous';
  img.onload = async ()=>{
    setPhase('Backend kiezen…'); log('Resolutie: '+(img.naturalWidth||img.width)+'×'+(img.naturalHeight||img.height));
    try{
      const be = await ensureBackend();
      setPhase('Pose detectie…');
      let pts=null, normalized=false;
      if(be==='tasks'){
        const res=await landmarker.detect(img);
        if(res && res.landmarks && res.landmarks.length){ pts=res.landmarks[0]; normalized=true; }
      }else{
        const out=await detector.estimatePoses(img,{flipHorizontal:false});
        if(out && out.length && out[0].keypoints){ pts=out[0].keypoints; normalized=false; }
      }
      if(!pts || !pts.length){ setPhase('Geen lichaam gedetecteerd'); log('Avatar teruggezet naar standaard.'); document.getElementById('out').textContent='Geen parameters gedetecteerd.'; drawPose(img,[],false); return; }
      drawPose(img, pts, normalized); log('Keypoints: '+pts.length);
      const prior =  parseInt((document.getElementById('height')||{}).value||'172',10) || 172;
      const est = estimate(pts, normalized, prior);
      const lines=[];
      if(est.scale) lines.push('Schaal ~ '+est.scale.toFixed(3)+' cm/unit');
      lines.push('Borst: ' + (est.chest ?? 'niet gedetecteerd'));
      lines.push('Taille: ' + (est.waist ?? 'niet gedetecteerd'));
      lines.push('Heup: ' + (est.hip ?? 'niet gedetecteerd'));
      lines.push('Schouderbreedte: ' + (est.shoulder ?? 'niet gedetecteerd'));
      document.getElementById('out').textContent = lines.join('\n');
      setPhase('Klaar');
    }catch(e){ setPhase('Fout bij analyse'); log(String(e)); }
  };
  img.onerror = ()=>{ setPhase('Fout: afbeelding kon niet geladen worden'); log('Kon bron niet laden: '+src); };
  img.src=src;
}

// ---------- UI wiring ----------
document.getElementById('close').onclick = hideO;
document.getElementById('cv-toggle').onchange = (e)=>{
  const on = e.target.checked;
  document.getElementById('cv-label').textContent = on? 'Terug naar demo mode':'computer vision proberen';
  // Hard reload for init
  const u = new URL(location.href); if(on) u.searchParams.set('cv','1'); else u.searchParams.delete('cv'); location.href = u.toString();
};
// Enable if ?cv=1 present
if(new URLSearchParams(location.search).get('cv')==='1'){ document.getElementById('cv-toggle').checked = true; document.getElementById('cv-label').textContent='Terug naar demo mode'; }

// Demo images known to work with MediaPipe models
const DEMOS = [
  "https://storage.googleapis.com/mediapipe-assets/pose_sample_1.jpg",
  "https://storage.googleapis.com/mediapipe-assets/pose_sample_2.jpg",
  "https://storage.googleapis.com/mediapipe-assets/pose_sample_3.jpg"
];
const smp = document.getElementById('samples');
DEMOS.forEach(u=>{ const im=new Image(); im.src=u; im.alt='demo'; im.referrerPolicy='no-referrer'; smp.appendChild(im); im.onclick=()=>analyze(u); });

document.getElementById('test1').onclick = ()=> analyze(DEMOS[0]);
document.getElementById('test2').onclick = ()=> analyze(DEMOS[1]);
document.getElementById('test3').onclick = ()=> analyze(DEMOS[2]);
document.getElementById('file').onchange = (e)=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>analyze(r.result); r.readAsDataURL(f); };
</script>
</body>
</html>
